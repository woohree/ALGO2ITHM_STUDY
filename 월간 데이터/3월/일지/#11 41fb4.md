# #11

모임 날짜: 2022년 3월 14일 오후 8:00-오후 9:30
참석: 이우현, 한빈 배, Yeonggyeong Gong, 마주리

![0314.png](#11%2041fb4/0314.png)

- 특이사항
    - 질문 0
    - 내일 시험 화이팅! 🤮
- 소감:
    - 공영경: dp의 어려움을 느꼈던 날 !
        - 과제는 끝나지 않아!
            - 다른 문제에 비해 쉽게 해결할 수 있었다.
            - 정말 과제는 끝나지 않는다...!
        - 프린터 큐
            - 문제제목에서 힌트를 얻어 큐로 접근 !
            - 문서의 번호를 확인하기위해서 index로만 이루어진 리스트를 생성
        - 촌수 계산
            - 어려웠다.
            - `dfs`와 `bfs` 를 어느 상황에 써야하는지 두 가지 방법의 구분이 아직까지는 좀 어렵다.
            - 항상 풀지만 항상 어떻게 이게 된거지..?라는 생각이 없어지질 않는다 ㅠㅠ
        - 포도주 시식
            - 음...어려웠다 이것두....ㅠ
            - dp는 정말 한 번 잘 못 생각하면, 되돌리기가 어렵다.
            - 한참을 붙잡고 있었지만 아이디어가 도저히 생각나지 않았다 ㅠㅠ
            - 다른 분들 풀이를 보고 좀 더 고민해봐야겠다 !
        
    - 마주리:
        
        이번 스터디는 스택, 큐, 그래프, dp가 모두 있던 날! 다들 모의 A형 시험 화이팅~
        
        - 과제는 끝나지 않아!
            - `pop`과 `append`를 사용해서 생각보다 간단하게 해결할 수 있었던 문제
        - 프린터 큐
            - 여러가지 조건들을 설정해야 했지만 `deque`를 사용해서 쉽게 풀 수 있었던 문제
            - `target_idx` 변수를 설정해서 내가 찾고자 하는 문서의 변화하는 위치를 저장했다.
        - 촌수 계산
            - 뭔가,,, 양방향 그래프로 저장을 안해도 풀 수 있을 것만 같았다... 이어진 노드들만 잘 찾으면 될거라 생각했었는데, 접근이 잘못되었는지 삽질을 꽤나 했던 문제
            - 시작점부터 `dfs` 방식으로 그래프를 탐색하면서 `distance`에 거리를 저장하는 방식으로 해결했다.
            - `dfs`를 좀 더 다양하게 사용하는 방식을 고민해볼 수 있었던 시간이었다.
        - 포도주시식
            - 여전히 `dp`는 너무 어렵다 ㅜㅜ
            - 3연속 선택은 안되니까 [o,x,o], [x,o,o], [o,o,x]의 경우의 최대값을 하나씩 증가해가면서 구하는 방식으로 해결했다.
            - 개인적으로 한빈님의 풀이가 흥미로웠다(?). dp 길이 3만 가지고도 풀 수 있구나...
            - `dp` 문제는 아무래도 연습이 더 필요할 듯 싶다. 풀 다 보면 실력이 늘겠조.....? 제발
    
    - 배한빈:
        - 과제는 끝나지 않아!
            - `stack`사용해서 비교적 간단하게 해결
        - 프린터 큐
            - `queue` 사용.
            - 문서의 중요도 순서를 기억해야하는 문제인데 우현님 코드처럼 `enumerate` 를 사용하면 더 간단하게 풀 수 있었을 것 같다.
        - 촌수계산
            - 풀다보니 그냥 어떻게 풀었지만 알고리즘 자체는 `dfs` 로 풀었다.
            - 코드 길이를 줄이는 노력이 필요할 것 같다.
        - 포도주 시식
            - 풀기도, 설명도 모두 어렵다. 설명하다보니 나도 헷갈려버리는...
            - 처음에 경우의 수도 쫙 나열해보고 고민하다가 표를 만들어서 한 칸씩 비교하면서 전진하니까 답이 나오드라
            - 이건 풀면서 사용했던 예제인데 이해에 도움이 될까 공유합니다.
            
            ![Untitled](#11%2041fb4/Untitled.png)
            
            - `0번 연속`이라 적혀있는 행은 항상 전 단계의 최댓값을 가져옵니다.
            - `1번 연속` 이라 적혀있는 행은 항상 전 단계의 `0번 연속`인 곳에 지금 값을 더합니다. 즉, 1번 연속이라 지금 숫자가 들어가야하는데 이 조건을 만족하려면 전 단계는 숫자가 안들어간 경우여야 한다.
            - `2번 연속` 이라 적혀있는 행은 항상 전 단계의 `1번 연속`인 곳에 지금 값을 더합니다. 마찬가지로 2번 연속으로 숫자가 들어간거면 전 단계는 1번 들어간 것이여야 하므로 다음과 같은 계산을 한 것.
        
    - 이우현:
        
        프린터랑 과제 문제가 금방 풀려서 방심했다. 역시나 알고리즘은 쉽지 않음이 분명하다.
        
        내일 시험, 첫 길을 잘 찾아야 할텐데.. 다들 화이팅!
        
        - 과제는 끝나지 않아!
            - 스택써서 후입선출 방식으로 과제 지워나가는 방식
        - 프린터 큐
            - `enumerate`를 쓸때 조금 주의해야할 필요성을 알게 된 문제다. `list` 혹은 `deque` 와 같은 함수를 쓸 때, `enumerate` 를 안쪽에 쓰는 습관을 들이자.
            - `enumerate`써서 인덱스뽑아다가 `M`뽑을 차례되면 종료하는 방식
        - 촌수계산
            - `DFS` 는 구현 자체는 쉬운데 어떻게 출력 값을 뽑을 지 정하는 게 어렵다. 이번에도 그거 때문에 고생 좀 했다.
            - `DFS` 방식으로 촌수관계 있는 사람들 다 뒤져가면서 입력받은 값들 사이의 촌수를 출력하는 방식
        - 포도주 시식(*시음이 아닐까?*)
            - 어찌어찌 `DP` 길을 찾아서 힘들게 푼 문제
            - 연속 3잔은 불가능하므로, 3잔전까지 + 최근 2잔 / 2잔전까지 + 최근 1잔 / 1잔전까지, 세 경우의 최댓값을 `DP` 에 저장해가며 `i` 의 `DP` 를 구하는 방식
            - 어렵다.. `DP` 진짜 어려워!!!
- 정리