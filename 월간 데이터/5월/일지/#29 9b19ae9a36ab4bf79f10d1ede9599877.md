# #29

모임 날짜: 2022년 5월 16일 오후 8:00-오후 9:50
참석: 이우현, 한빈 배, Yeonggyeong Gong, 마주리

![0516.png](#29%209b19ae9a36ab4bf79f10d1ede9599877/0516.png)

- 특이사항
    - 사이좋은 형제 전멸.. 문제가 너무 어지러웠다..
    - 내일부터 프로젝트 시작
    - 5/18 이우현 KB 국민은행 1차면접 예정
    - 영경, 주리 신한은행 코딩테스트 리뷰
- 소감:
    - 공영경:
        
        사이좋은 형제는 원래 사이가 안 좋은가….그냥 먹었으면 좋겠다…
        
        - 비슷한 단어
            - 동일 최장 접두사의 개수가 있을 때 빨리 나온 단어를 출력하기 위해서 인덱스까지 같이 저장
            - 비슷한 단어들을 모으기 위해 정렬 시행 !
            - 앞 뒤 단어들간의 공통 접두사를 구하기!
        - 알파벳
            - bfs는 아니지만 속도를 빠르게 하기 위해 deque를 불러왔다!
            - 문제를 풀고 안 사실이지만 dfs 할 때 인자 같이 넣으면 좋은 것 같다.
        - 중량제한
            - 유니온파인드를 사용!
            - 우현오빠가 시간 줄이는 법을 알려줘서 스터디 시간에 풀 수 있었다!
        
    - 마주리:
        
        비슷한 단어는 도전했는데, 풀지 못했다. 인덱스를 저장해두고 정렬을 한다는 방식을 생각을 못했는데, 조만간 다시 도전해봐야겠다.
        
        사이좋은 형제는.... 그냥 처음부터 절반 나누면 안될까.... 💦 먹다가 사이 나빠질 듯
        
        - 알파벳
            - dfs를 이용해서 풀었다.
            - 재귀를 통해서 한 칸씩 이동할 때마다 방문한 문자열을 하나씩 더해서 인자로 보내 비교하는 방식이었다.
            - python 3으로는 시간초과,, pypy 3로만 통과!
        - 중량제한
            - 상호배타집합을 통해 문제를 풀었다.
            - 중량을 비교하기 위해서 중량제한을 기준으로 각 노드를 내림차순 정렬한 뒤 비교해주는 것이 중요했다.
    
    - 배한빈:
        - **비슷한 단어**
            
            ```markdown
            1. 단어들의 인덱스를 기억해야 해서 `(index, word)` 꼴로 words 만들고 알파벳 순으로 정렬
            2. 단어의 접두사를 key값으로 하고 value에는 해당 단어들을 갖는 `딕셔너리 result`를 만듬
            3. 단어의 접두사가 이미 result에 저장되어 있는 경우, value에 일단 넣고 index로 정렬한 다음 맨 뒤에 단어 pop시킴
            4. result의 values 를 answer_temp에 extends 시키고 다시 index 기준으로 정렬
            5. answer_temp의 첫번째 요소를 answer에 넣고 해당 접두사를 뽑아 그 다음 접두사가 일치하는 단어 찾고 break
            ```
            
        - **알파벳**
            - `dfs`로 풀이.. 사실 `bfs`인줄 알았는데 아녔음. `dfs == 재귀`라는 편협한 사고방식에서 비롯된 판단
            - 만난 알파벳들을 계속 이러 붙여서 하나의 문자열을 만들어 가면서 `if board[nr][nc] not in alphabets` 이런 식으로 알파벳 중복 사용을 판단
        - **중량제한**
            
            ```markdown
            1. 다익스트라 식으로 input 값을 bridges 라는 리스트에 저장
            2. 다리의 중량 제한을 통과 가능한 중량을 이분탐색으로 찾음.
            3. bfs 사용. 현재 중량이 다리를 건너다가 목적지에 도착하면 True를 return, 반대로 목적지에 못 도달하면 False를 return.
            4. True 면 low 에 +1, False 면 high 에 -1 해주면서 low 가 high 보다 커질 때는 찾은 후 high 를 출력
            ```
            
        - **사이좋은 형제**
            - 문제 자체가 어지럽다. 스터디원들과 사이 나빠질 뻔
    - 이우현:
        
        쉽지 않았다... 주말에 노느라 바빠서 너무 몰아 풀었다... 반성을 하자...
        
        - 중량 제한
            - `dfs`로 최대 무게에 따른 경로가 있는지 파악하고, 있다면 더 큰 무게에서, 없다면 더 작은 무게에서 찾아보면서 최대 무게를 포함할 수 있는 경로를 찾는 방식
            - `투 포인터` 문제인데, 이게 개념은 참 쉬운데 문제에 맞게 가공하는게 생각보다 쉽지 않다. 머리가 잘 안돌아감!! 비슷한 문제를 벌써 몇개는 푼거 같은데 ㅠㅠ
        - 알파벳
            - 그냥 `dfs`, 그러나 딕셔너리로 방문체크를 하면 뻑나고 무적권! 리스트로 해야함
            - 어거지다 어거지,,, 인정하고 싶지 않다 문제를,,,
        - 비슷한 단어
            - 문자열들을 정렬해서 앞뒤로 같은 접두사의 길이를 저장하고, 최대 길이의 접두사가 포함된 단어를 다시 찾아다가 2개만 순서대로 뽑는 방식
            - 정렬을 해서 같은 접두사 길이까지 뽑아다가 다 정리했는데, 그걸 가지고 원래 있던 배열에서 순서에 접근하는 방법을 몰라서 결국 구글링,,,
            - 아쉽지만, 고민한다고 풀렸을 것 같지도 않다.
        - 사이좋은 형제
            - 문제가 어지럽다 ⇒ 질문을 봤는데 더 어지러웠다 ⇒ ...